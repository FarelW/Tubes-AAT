import { Worker, isMainThread, parentPort, workerData } from 'worker_threads';
import { fileURLToPath } from 'url';
import path from 'path';
import http from 'http';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ===========================================
// CONFIGURATION
// ===========================================

const LOAD_LEVELS = {
  light: {
    name: 'Light',
    writeRPS: 100,
    readRPS: 400,
    duration: 10,
    workers: 4,
    description: '~500 req/sec (4 workers)'
  },
  medium: {
    name: 'Medium', 
    writeRPS: 500,
    readRPS: 2000,
    duration: 10,
    workers: 8,
    description: '~2500 req/sec (8 workers)'
  },
  heavy: {
    name: 'Heavy',
    writeRPS: 1000,
    readRPS: 4000,
    duration: 10,
    workers: 16,
    description: '~5000 req/sec (16 workers)'
  },
  extreme: {
    name: 'Extreme',
    writeRPS: 2000,
    readRPS: 8000,
    duration: 10,
    workers: 32,
    description: '~10000 req/sec (32 workers)'
  },
  stress: {
    name: 'Stress',
    writeRPS: 5000,
    readRPS: 20000,
    duration: 10,
    workers: 64,
    description: '~25000 req/sec (64 workers)'
  },
  max: {
    name: 'Maximum',
    writeRPS: 10000,
    readRPS: 40000,
    duration: 10,
    workers: 128,
    description: '~50000 req/sec (128 workers)'
  }
};

const CATEGORIES = ['kebersihan', 'kriminalitas', 'infrastruktur', 'kesehatan', 'keamanan', 'lainnya'];

// ===========================================
// WORKER THREAD CODE
// ===========================================

if (!isMainThread) {
  const { workerId, type, targetRPS, duration, baseUrl } = workerData;
  
  const results = {
    workerId,
    type,
    requests: 0,
    success: 0,
    failed: 0,
    responseTimes: [],
    instances: {},
    errors: {}
  };

  const agent = new http.Agent({ 
    keepAlive: true, 
    maxSockets: 100,
    keepAliveMsecs: 30000
  });

  function makeRequest(options) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      
      const req = http.request({
        ...options,
        agent,
        timeout: 10000
      }, (res) => {
        let data = '';
        res.on('data', chunk => data += chunk);
        res.on('end', () => {
          const responseTime = Date.now() - startTime;
          try {
            const json = JSON.parse(data);
            resolve({
              success: res.statusCode >= 200 && res.statusCode < 300,
              responseTime,
              instance: json.instance || 'unknown',
              statusCode: res.statusCode
            });
          } catch {
            resolve({
              success: res.statusCode >= 200 && res.statusCode < 300,
              responseTime,
              instance: 'unknown',
              statusCode: res.statusCode
            });
          }
        });
      });

      req.on('error', (err) => {
        resolve({
          success: false,
          responseTime: Date.now() - startTime,
          instance: 'error',
          error: err.code || err.message
        });
      });

      req.on('timeout', () => {
        req.destroy();
        resolve({
          success: false,
          responseTime: Date.now() - startTime,
          instance: 'error',
          error: 'TIMEOUT'
        });
      });

      if (options.body) {
        req.write(options.body);
      }
      req.end();
    });
  }

  async function runWorker() {
    const interval = 1000 / targetRPS;
    const endTime = Date.now() + (duration * 1000);
    let requestIndex = 0;

    const promises = [];

    while (Date.now() < endTime) {
      requestIndex++;
      
      let options;
      if (type === 'write') {
        const report = {
          title: `Load Test Report #${workerId}-${requestIndex}`,
          description: `Generated by worker ${workerId}`,
          category: CATEGORIES[Math.floor(Math.random() * CATEGORIES.length)]
        };
        options = {
          hostname: 'localhost',
          port: 8080,
          path: '/reports',
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(report)
        };
      } else {
        // Random read operation
        const rand = Math.random();
        if (rand < 0.4) {
          options = { hostname: 'localhost', port: 8090, path: '/reports', method: 'GET' };
        } else if (rand < 0.7) {
          const cat = CATEGORIES[Math.floor(Math.random() * CATEGORIES.length)];
          options = { hostname: 'localhost', port: 8090, path: `/reports?category=${cat}`, method: 'GET' };
        } else if (rand < 0.9) {
          options = { hostname: 'localhost', port: 8090, path: '/statistics', method: 'GET' };
        } else {
          options = { hostname: 'localhost', port: 8090, path: '/health', method: 'GET' };
        }
      }

      const promise = makeRequest(options).then(result => {
        results.requests++;
        if (result.success) {
          results.success++;
          results.instances[result.instance] = (results.instances[result.instance] || 0) + 1;
        } else {
          results.failed++;
          const errKey = result.error || `HTTP_${result.statusCode}`;
          results.errors[errKey] = (results.errors[errKey] || 0) + 1;
        }
        results.responseTimes.push(result.responseTime);
      });

      promises.push(promise);

      // Throttle
      if (interval > 0.1) {
        await new Promise(r => setTimeout(r, interval));
      }
    }

    await Promise.all(promises);
    parentPort.postMessage(results);
  }

  runWorker();
}

// ===========================================
// MAIN THREAD CODE  
// ===========================================

if (isMainThread) {
  const args = process.argv.slice(2);
  let level = 'light';
  let testType = 'both';

  for (const arg of args) {
    if (LOAD_LEVELS[arg]) level = arg;
    if (['write', 'read', 'both'].includes(arg)) testType = arg;
  }

  const config = LOAD_LEVELS[level];

  console.log('\nüöÄ PARALLEL LOAD TEST (Multi-Threaded)');
  console.log('‚ïê'.repeat(60));
  console.log(`üìä Level: ${config.name}`);
  console.log(`üìù ${config.description}`);
  console.log(`‚è±Ô∏è  Duration: ${config.duration}s per test`);
  console.log(`üîß Workers: ${config.workers}`);
  console.log(`üìã Test Type: ${testType.toUpperCase()}`);
  console.log('‚ïê'.repeat(60));

  async function runTest(type, totalRPS, workerCount, duration) {
    console.log(`\nüìã ${type.toUpperCase()} LOAD TEST`);
    console.log(`   Target: ${totalRPS} req/sec with ${workerCount} workers`);
    console.log(`   Per Worker: ${Math.ceil(totalRPS / workerCount)} req/sec`);
    
    const rpsPerWorker = Math.ceil(totalRPS / workerCount);
    const workers = [];
    const results = [];
    const startTime = Date.now();

    for (let i = 0; i < workerCount; i++) {
      const worker = new Worker(__filename, {
        workerData: {
          workerId: i + 1,
          type,
          targetRPS: rpsPerWorker,
          duration,
          baseUrl: type === 'write' ? 'http://localhost:8080' : 'http://localhost:8090'
        }
      });

      workers.push(new Promise((resolve) => {
        worker.on('message', (result) => {
          results.push(result);
          resolve();
        });
        worker.on('error', (err) => {
          console.error(`Worker ${i} error:`, err);
          resolve();
        });
      }));
    }

    await Promise.all(workers);
    const totalDuration = (Date.now() - startTime) / 1000;

    // Aggregate results
    const aggregated = {
      totalRequests: 0,
      success: 0,
      failed: 0,
      responseTimes: [],
      instances: {},
      errors: {}
    };

    for (const r of results) {
      aggregated.totalRequests += r.requests;
      aggregated.success += r.success;
      aggregated.failed += r.failed;
      aggregated.responseTimes.push(...r.responseTimes);
      
      for (const [inst, count] of Object.entries(r.instances)) {
        aggregated.instances[inst] = (aggregated.instances[inst] || 0) + count;
      }
      for (const [err, count] of Object.entries(r.errors)) {
        aggregated.errors[err] = (aggregated.errors[err] || 0) + count;
      }
    }

    // Calculate stats
    const sortedTimes = aggregated.responseTimes.sort((a, b) => a - b);
    const avgTime = sortedTimes.length > 0 
      ? (sortedTimes.reduce((a, b) => a + b, 0) / sortedTimes.length).toFixed(2)
      : 0;
    const p50 = sortedTimes[Math.floor(sortedTimes.length * 0.5)] || 0;
    const p95 = sortedTimes[Math.floor(sortedTimes.length * 0.95)] || 0;
    const p99 = sortedTimes[Math.floor(sortedTimes.length * 0.99)] || 0;
    const actualRPS = (aggregated.totalRequests / totalDuration).toFixed(2);
    const successRate = ((aggregated.success / aggregated.totalRequests) * 100).toFixed(2);

    console.log(`\n   üìä RESULTS:`);
    console.log(`   ‚îú‚îÄ Total Requests: ${aggregated.totalRequests}`);
    console.log(`   ‚îú‚îÄ Success: ${aggregated.success} | Failed: ${aggregated.failed}`);
    console.log(`   ‚îú‚îÄ Success Rate: ${successRate}%`);
    console.log(`   ‚îú‚îÄ Duration: ${totalDuration.toFixed(2)}s`);
    console.log(`   ‚îú‚îÄ Actual RPS: ${actualRPS}`);
    console.log(`   ‚îú‚îÄ Avg Response: ${avgTime}ms`);
    console.log(`   ‚îî‚îÄ P50: ${p50}ms | P95: ${p95}ms | P99: ${p99}ms`);

    console.log(`\n   üñ•Ô∏è  Instance Distribution:`);
    for (const [inst, count] of Object.entries(aggregated.instances)) {
      const pct = ((count / aggregated.success) * 100).toFixed(1);
      console.log(`   ‚îú‚îÄ ${inst}: ${count} (${pct}%)`);
    }

    if (Object.keys(aggregated.errors).length > 0) {
      console.log(`\n   ‚ö†Ô∏è  Errors:`);
      for (const [err, count] of Object.entries(aggregated.errors)) {
        console.log(`   ‚îú‚îÄ ${err}: ${count}`);
      }
    }

    return aggregated;
  }

  async function main() {
    // Check health first
    console.log('\nüîç Checking services health...');
    try {
      const res = await fetch('http://localhost:8080/health');
      if (!res.ok) throw new Error('Command service not ready');
      const res2 = await fetch('http://localhost:8090/health');
      if (!res2.ok) throw new Error('Query service not ready');
      console.log('‚úÖ All services healthy!\n');
    } catch (err) {
      console.error('‚ùå Services not ready:', err.message);
      process.exit(1);
    }

    let writeResults, readResults;

    if (testType === 'write' || testType === 'both') {
      writeResults = await runTest('write', config.writeRPS, config.workers, config.duration);
    }

    if (testType === 'both') {
      console.log('\n‚è≥ Waiting for eventual consistency (3s)...');
      await new Promise(r => setTimeout(r, 3000));
    }

    if (testType === 'read' || testType === 'both') {
      readResults = await runTest('read', config.readRPS, config.workers, config.duration);
    }

    // Summary
    console.log('\n' + '‚ïê'.repeat(60));
    console.log('üìà SUMMARY');
    console.log('‚ïê'.repeat(60));
    
    if (writeResults && readResults) {
      const totalReq = writeResults.totalRequests + readResults.totalRequests;
      const totalSuccess = writeResults.success + readResults.success;
      const totalFailed = writeResults.failed + readResults.failed;
      console.log(`Total Requests: ${totalReq}`);
      console.log(`Total Success: ${totalSuccess} | Failed: ${totalFailed}`);
      console.log(`Overall Success Rate: ${((totalSuccess / totalReq) * 100).toFixed(2)}%`);
    }

    console.log('\nüìã Available levels:');
    for (const [key, val] of Object.entries(LOAD_LEVELS)) {
      console.log(`   ${key}: ${val.description}`);
    }
    console.log('\nüìã Usage: node parallel-load-test.js [level] [type]');
    console.log('   Types: write, read, both');
  }

  main().catch(console.error);
}

